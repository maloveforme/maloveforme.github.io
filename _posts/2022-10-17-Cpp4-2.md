---

title: "Chapter 4 Object Pointer, Array, Dynamically Allocation(2)"
layout: single
categories:

  - language

tags:
  - Cpp

published: false

---

### 객체와 객체 배열의 동적 생성 및 반환

<br>

```cpp
// 예제 4-7
#include <iostream>
using namespace std;

class Circle
{
    int radius;

public:
    Circle(); // default constructor
    Circle(int r); // constructor
    ~Circle(); // destructor
    void setRadius(int r) { radius = r; } // Inline function
    double getArea() { return 3.14 * radius * radius; } // Inline function
};

Circle::Circle() : radius(1) {}
Circle::Circle(int r)
{
    radius = r;
    cout << "생성자 실행 radius = " << radius << endl;
}
Circle::~Circle() { cout << "소멸자 실행" << endl; }

int main()
{
    Circle* p, * q; // 포인터 객체 선언
    p = new Circle; q = new Circle(30); // 동적 할당

    cout << p->getArea() << endl << q->getArea() << endl;

    delete p; delete q; 
}
```

<br>

- 객체의 동적 생성 및 반환

  - 동적 생성: 클래스 크기의 메모리를 할당받아 객체를 생성

    ```cpp
    <클래스이름> *<포인터변수> = new <클래스이름>; // 기본 생성자 호출
    <클래스이름> *<포인터변수> = new <매개변수>; // 매개 변수 있는 생성자 호출
    ```

  - 객체 반환: 동적으로 할당받은 객체 반환.

    ```cpp
    delete <포인터변수>
    ```

    - 이때 <포인터변수>는 반드시 **new를 이용해 동적 할당받은 메모리의 주소**여야 한다.
    - **객체를 반환하기 전에 객체 소멸자가 먼저 실행**된다.

<br>

```cpp
// 예제 4-8
// 정수 값으로 반지름을 입력받고, Circle 객체를 동적 생성하여 면적을 출력하는 프로그램.
// 음수가 입력되면 프로그램은 종료한다.
#include <iostream>
using namespace std;

class Circle
{
    int radius;

public:
    Circle(); // default constructor
    Circle(int r); // constructor
    ~Circle(); // destructor
    void setRadius(int r) { radius = r; } // Inline function
    double getArea() { return 3.14 * radius * radius; } // Inline function
};

Circle::Circle() : radius(1) {}
Circle::Circle(int r)
{
    radius = r;
    cout << "생성자 실행 radius = " << radius << endl;
}
Circle::~Circle() { cout << "소멸자 실행" << endl; }

int main()
{
    int radius;

    while (true)
    {
        cout << "정수 반지름 입력(음수면 종료)>> ";
        cin >> radius;

        if (radius < 0)
            break;

        Circle* p = new Circle(radius);

        cout << "원의 면적은 " << p->getArea() << endl;
        
        delete p;
    }
}

```

<br>

```cpp
// 예제 4-9
#include <iostream>
using namespace std;

class Circle
{
    int radius;

public:
    Circle(); // default constructor
    Circle(int r); // constructor
    ~Circle(); // destructor
    void setRadius(int r) { radius = r; } // Inline function
    double getArea() { return 3.14 * radius * radius; } // Inline function
};

Circle::Circle() : radius(1) {}
Circle::Circle(int r)
{
    radius = r;
    cout << "생성자 실행 radius = " << radius << endl;
}
Circle::~Circle() { cout << "소멸자 실행 radius = " << radius << endl; }

int main()
{
    int arraySize = 3;
    Circle* pArray = new Circle[arraySize]; // 객체 배열의 동적 생성

    for (int i = 0; i < arraySize; i++)
    {
        pArray[i].setRadius(10 * (i+1));
        cout << pArray[i].getArea() << endl;
    }

    Circle* p = pArray; // 포인터 p에 배열의 주소값 저장

    for (int i = 0; i < arraySize; i++)
    {
        cout << p->getArea() << endl;
        p++; // 다음 주소
    }

    delete[] pArray; // 객체 배열 반환
}
```

<br>

- 객체 배열의 동적 생성 및 반환

  - 동적 생성: 각 **객체에 대해 기본 생성자를 호출**한다. 이**때 매개 변수 있는 생성자를 직접 호출할 수 없지만 배열을 각 원소 객체로 초기화**할 수 있다.

    ```cpp
    <클래스이름> *<포인터변수> = new <클래스이름> [배열 크기];
    <클래스이름> *<포인터변수> 
        = new <클래스이름> [배열 크기] { <클래스이름>(매개변수), <클래스이름>(매개변수)};
    // 매개변수 있는 생성자 호출 방법
    ```

  
  - 객체 배열 반환: 소멸자의 실행 순서는 생성의 역순.
  
    ```cpp
    delete [] <포인터변수>;
    ```
  
  - 객체 배열의 사용
  
    - 동적으로 생성된 객체 배열은 보통 객체 배열처럼 사용한다.

<br>

```cpp
// 예제 4-10
// 원의 개수를 입력받고 Circle 배열을 동적 생성하기.
// 반지름 값을 입력받아 Circle 배열에 저장하고, 면적이 100에서 200인 원의 개수를 출력하라.
#include <iostream>
using namespace std;

class Circle
{
    int radius;

public:
    Circle(); 
    Circle(int r); 
    void setRadius(int r) { radius = r; } 
    double getArea() { return 3.14 * radius * radius; } 
};

Circle::Circle() : radius(1) {}
Circle::Circle(int r)
{
    radius = r;
    cout << "생성자 실행 radius = " << radius << endl;
}

int main()
{
    cout << "원의 개수를 입력하세요>> ";
    int arraySize = 0;
    cin >> arraySize;

    Circle* pArray = new Circle[arraySize]; 

    int radius = 0;

    for (int i = 0; i < arraySize; i++)
    {
        cout << i + 1 << "번째 원의 반지름을 입력하세요 >> ";
        cin >> radius;
        pArray[i].setRadius(radius);
    }

    Circle* p = pArray; 

    int count = 0;

    for (int i = 0; i < arraySize; i++)
    {
        if (p->getArea() >= 100 && p->getArea() <= 200)
        {
            cout << p->getArea() << ", ";
            count++;
        }
        p++;
    }

    cout << endl << "100에서 200 사이의 면적을 가진 원의 개수는 " << count << "개입니다." << endl;

    delete[] pArray; // 
}
```

<br>

- <span style = "color:red">**힙(heap)**</span>: 응용프로그램들이 **실행 중에 할당받아 사용하는 시스템 메모리**
  - 동적으로 할당받은 메모리는 메모리 누수가 발생할 수 있으므로 **필요 없을 때 힙에 반환**하여 메모리 공간을 여유롭게 하는 것이 바람직하다. 
    - <span style = "color:red"> **메모리 누수(memory leak)**</span>: 동적으로 할당받은 메모리의 주소를 잃어버려 힙에 반환할 수 없을 때 발생하는 것.
  - **new**를 이용하여 할당받은 메모리는 **프로그램이 종료할 때 자동으로 힙에 반환**한다.

---

### this 포인터
